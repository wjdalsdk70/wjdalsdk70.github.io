---
title: "TypeScript로 안전한 개발하기"
date: "2024-01-10"
description: "TypeScript의 타입 시스템을 활용하여 더 안전하고 유지보수하기 좋은 코드를 작성하는 방법을 소개합니다. 실제 프로젝트에서의 적용 사례도 함께 다룹니다."
---

# TypeScript로 안전한 개발하기

TypeScript는 JavaScript에 정적 타입 검사를 추가하여 개발 과정에서 발생할 수 있는 많은 오류를 미리 방지할 수 있게 해주는 언어입니다. 이 글에서는 TypeScript의 핵심 기능과 실제 활용 방법을 알아보겠습니다.

## TypeScript란?

TypeScript는 Microsoft에서 개발한 JavaScript의 상위 집합(Superset) 언어입니다. JavaScript 코드에 타입 정보를 추가하여 컴파일 시점에 타입 오류를 검출할 수 있습니다.

## 기본 타입 정의

TypeScript에서는 변수, 함수, 객체 등에 명시적으로 타입을 지정할 수 있습니다.

```typescript
// 기본 타입
let name: string = "이정민";
let age: number = 25;
let isStudent: boolean = true;
let hobbies: string[] = ["코딩", "독서", "운동"];

// 객체 타입
interface User {
  id: number;
  name: string;
  email: string;
  age?: number; // 선택적 속성
}

const user: User = {
  id: 1,
  name: "이정민",
  email: "jeongmin@example.com"
};
```

## 함수 타입 정의

함수의 매개변수와 반환값에 타입을 지정할 수 있습니다.

```typescript
// 함수 타입 정의
function add(a: number, b: number): number {
  return a + b;
}

// 화살표 함수
const multiply = (a: number, b: number): number => a * b;

// 선택적 매개변수
function greet(name: string, greeting?: string): string {
  return greeting ? `${greeting}, ${name}!` : `안녕하세요, ${name}!`;
}

// 기본값이 있는 매개변수
function createUser(name: string, age: number = 20): User {
  return {
    id: Date.now(),
    name,
    age
  };
}
```

## 제네릭 활용

제네릭을 사용하면 타입에 구애받지 않는 재사용 가능한 컴포넌트를 만들 수 있습니다.

```typescript
// 제네릭 함수
function identity<T>(arg: T): T {
  return arg;
}

// 제네릭 인터페이스
interface ApiResponse<T> {
  data: T;
  status: number;
  message: string;
}

// 제네릭 클래스
class Queue<T> {
  private items: T[] = [];

  enqueue(item: T): void {
    this.items.push(item);
  }

  dequeue(): T | undefined {
    return this.items.shift();
  }

  peek(): T | undefined {
    return this.items[0];
  }

  isEmpty(): boolean {
    return this.items.length === 0;
  }
}

// 사용 예시
const numberQueue = new Queue<number>();
numberQueue.enqueue(1);
numberQueue.enqueue(2);
numberQueue.enqueue(3);

const stringQueue = new Queue<string>();
stringQueue.enqueue("hello");
stringQueue.enqueue("world");
```

## 유니온 타입과 타입 가드

여러 타입을 허용하는 유니온 타입과 타입 가드를 활용할 수 있습니다.

```typescript
// 유니온 타입
type Status = "loading" | "success" | "error";

// 타입 가드
function isString(value: unknown): value is string {
  return typeof value === "string";
}

function isNumber(value: unknown): value is number {
  return typeof value === "number";
}

function processValue(value: string | number): string {
  if (isString(value)) {
    return value.toUpperCase();
  } else if (isNumber(value)) {
    return value.toString();
  }
  throw new Error("지원하지 않는 타입입니다.");
}

// 사용 예시
console.log(processValue("hello")); // "HELLO"
console.log(processValue(42)); // "42"
```

## 실제 프로젝트 적용 사례

### API 응답 타입 정의

```typescript
// API 응답 타입들
interface User {
  id: number;
  name: string;
  email: string;
  profile: Profile;
}

interface Profile {
  avatar: string;
  bio: string;
  location: string;
}

interface ApiResponse<T> {
  data: T;
  success: boolean;
  message: string;
}

// API 함수
async function fetchUser(id: number): Promise<ApiResponse<User>> {
  try {
    const response = await fetch(`/api/users/${id}`);
    const data = await response.json();
    return data;
  } catch (error) {
    throw new Error(`사용자 정보를 가져오는데 실패했습니다: ${error}`);
  }
}

// 사용 예시
async function displayUser(id: number) {
  try {
    const result = await fetchUser(id);
    if (result.success) {
      console.log(`사용자: ${result.data.name}`);
      console.log(`이메일: ${result.data.email}`);
    }
  } catch (error) {
    console.error("오류:", error);
  }
}
```

### React 컴포넌트 타입 정의

```typescript
import React, { useState, useEffect } from 'react';

interface UserCardProps {
  user: User;
  onEdit?: (user: User) => void;
  onDelete?: (id: number) => void;
}

const UserCard: React.FC<UserCardProps> = ({ user, onEdit, onDelete }) => {
  const [isEditing, setIsEditing] = useState(false);

  const handleEdit = () => {
    if (onEdit) {
      onEdit(user);
      setIsEditing(false);
    }
  };

  const handleDelete = () => {
    if (onDelete && confirm("정말 삭제하시겠습니까?")) {
      onDelete(user.id);
    }
  };

  return (
    <div className="user-card">
      <img src={user.profile.avatar} alt={user.name} />
      <h3>{user.name}</h3>
      <p>{user.email}</p>
      <div className="actions">
        {onEdit && (
          <button onClick={handleEdit} disabled={isEditing}>
            수정
          </button>
        )}
        {onDelete && (
          <button onClick={handleDelete} className="delete">
            삭제
          </button>
        )}
      </div>
    </div>
  );
};
```

## TypeScript 설정 파일

프로젝트 루트에 `tsconfig.json` 파일을 생성하여 TypeScript 컴파일러 옵션을 설정할 수 있습니다.

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["DOM", "DOM.Iterable", "ES6"],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "module": "ESNext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}
```

## 결론

TypeScript는 대규모 프로젝트에서 코드의 안정성과 유지보수성을 크게 향상시킬 수 있는 강력한 도구입니다. 

타입 정의를 통해 개발 과정에서 발생할 수 있는 오류를 미리 방지하고, 코드의 가독성과 문서화 효과도 얻을 수 있습니다. 처음에는 타입 정의에 시간이 걸릴 수 있지만, 장기적으로는 개발 생산성과 코드 품질을 크게 향상시킬 수 있습니다.

이 글에서 다룬 내용들을 바탕으로 실제 프로젝트에 TypeScript를 적용해보시기 바랍니다! 